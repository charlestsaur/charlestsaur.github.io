FIFO 与 FILO 的示意图
### 7.4 FIFO与FILO

### 7.4.1.FIFO
FIFO 是一种特殊的存储器，你也可以叫它队列(Queue)。见图 A，它的特点就是先进先出。 队列有两个端口用于存取数据，不妨分别叫它们 IN 端和 OUT 端。你能作的就是不断将数据从 IN 端塞入队列中，然后再从 OUT 端取出它，最先进入队列的元素会最先被取出。

如果要做一个直观的比方，那就把它想象成游乐场入口的队列，很明显先进入队列的人肯定总是要比后进入队列的人先进入游乐场。 (当然，插队是禁止的!)
 
FIFO 至少有两种最基本操作，分别是入队和出队。出队就是通过 OUT 端从队列读取一个数，入队就是将数据从 IN 端送入 FIFO 中。 如果对应到上面的比喻，入队就是人从队列的末尾入队，出队就是人在银行窗口完成事务离开队列。

FIFO 的用途有许多，主要是用来缓冲数据。 

### 7.4.2 FILO

FILO 又名栈(Stack)。见图 B，FILO 与 FIFO 类似，但区别在于 FILO 是先进后出的。

FILO 类似有口无肛的腔肠动物，它只有一个端口，你也只能从这个端口写入/读取数据，不妨把这个端口叫做 HEAD 端。

FILO 也至少有两种基本操作，分别是入栈(PUSH)和出栈(POP)。入栈就是把元素放入栈的顶部，出栈就是把 FILO 最前的元素取出来(也就是上次入栈的元素)。

FILO 主要用于暂时存放一些数据，有时也会在一些算法中得到应用。有一种类型的计算机叫堆栈机，它们就是以栈为基础的，但这 种计算机仅在上世纪活跃过一段时间，现在的堆栈机只是一种较为冷门的非主流体系。

### 7.5 查找表与内容可寻址单元

### 7.5.1 查找表(LUT，Look Up Table)

LUT 的本质就是一个 RAM。把数据事先存入这个 RAM 中后，输入地址 n 就能得到这个地址所对应单元内的数据。LUT 的用途非常广泛，它可以用来存储一些经常用到的常数，或者用 LUT 来实现某个映射。(映射输入是地址 n，输出是对应单元的内容)

如果将一个逻辑电路的真值表存于 LUT 中，那么这个 LUT 将可以模拟这个逻辑电路。因此 LUT 还是 FPGA(现场可编程门阵列)的重要基础组成单元。

### 7.5.2 内容可寻址单元(CAM，Content Addressable memory)

CAM 相当于升级版的 LUT。它的每个存储项都由两个存储单元组成，第一个存储单元存储的内容叫 TAG，第二个存储单元的内容叫 DATA。(如果你学过编程，可以把 CAM 当作编程中的关联数组)

CAM可以进行匹配搜索。首先对CAM输入一个 TAG，然后这个 TAG会与CAM中每个存储项的 TAG进行匹配，如果输入的 TAG 跟某个存储项的 TAG匹配了，那么则输出这个被匹配的存储项的DATA。如果没有任何一个存储项与其匹配，CAM则会输出一个信号表示匹配失败。

此外，CAM也应该支持普通的访问方式(每个存储单元有一个唯一的物理地址)，以用于修改每个存储项的TAG和DATA的值。 当你需要从一大堆数据项中找到某个匹配的数据项时，就可以使用 CAM 来提高效率。

### 7.6 带特殊功能的寄存器

有时我们会给寄存器添加一些特殊功能以让寄存器本身获得一定的数据处理功能，这在一些时候会很方便。

### 7.6.1 计数器(Counter)

 计数器就是带有自增功能的寄存器(给寄存器内部的数据自增，)，自增功能就是给寄存器里的数值“+1”，如控制自增功能的引脚收到一个下降沿信号后给寄存器内的值+1。有时也会让它提供自减也就是“-1”的功能。当然需要的话让它提供“+n”或“-n”功能也可以。 另外说一下，对于二进制计数器，如果要让它±2𝑛 ，可以让计数器从第 n 位开始+1 或-1，这样±2𝑛 的开销还是跟普通的±1一样。 同理对于 k 进制计数器，让它±𝑘𝑛也可以有同样的做法。

### 7.6.1.1 计数器的实现

实现计数器最简单的办法就是直接用一个加法器来实现+n 的功能，但是实际上有更好的办法。

大部分情况下计数器都只需要+1 或者-1 这两种功能。你可以先建立一个完整的加法器，然后仅利用最低位进位输入 Cin 来实现+1 功能，这时你会发现加法器有一半的输入端是用不到的，删去多余的电路部分后，就留下了一个仅具备+1 功能的电路了。对于-1 而言，也 是在减法器上进行相同的步骤。

### 7.6.2 TODO

此外，有关+1 还有另外一种算法:从最低位开始不断取反，直到遇到某个位为 0。(遇到的这个位也会被取反) -1 也有类似的算法:从最低位开始不断取反，直到遇到某个位为 1。(遇到的这个位也会被取反) 如果要实现±2𝑛 ，请从第 n 位开始执行这个算法。(最低位是第 0 位) 基于触发器的“异步计数器”和“同步计数器”电路就是基于该算法的，相关电路可以自行搜索查找。

移位寄存器(Shift Register) 移位寄存器就是自带移位功能的寄存器(可以让寄存器内部的数据移位)，它自带左移或者右移或者两种移位功能。具体来算移位还分算数移位和逻辑移位等等各种不同的移位运算，总之需要多少功能你就加多少功能。

许多情况下电路只会用到带有左移 1 位或者右移 1 位功能的移位寄存器，这时只需要把线歪一下(第 n 位输出接到第 n+1 位输入实现左移，或接到第 n-1 位输入实现右移动)就行了。对于仅带有左移或者右移2𝑛位功能的移位寄存器来说，也是同理。 

### 7.6.2.1 二维移位寄存器(Two Dimension Shift Register)

二维移位寄存器是在一个二维的 bit 阵列上进行移位操作的寄存器。想象一个由 1 和 0 摆成的方阵，让它所有的元素同时朝某个方向移动(上、下、左、右)的样子，这就是二维的移位寄存器。多维移位阵列也同理。

二维或者多维的移位寄存器在实际中用的比较少，主要运用在某些特殊的算法或者张量的运算器中。

### 7.6.3 线性反馈移位寄存器(LFSR，Linear Feedback Shift Register)

LFSR 是一种常用于生成伪随机数的器件，它是基于移位寄存器的。(一维的，当然你要做多维的也不是不可以)

移位寄存器每次会左移 1 位，左移 1 位后最低位会空出来，在一般的移位运算中我们会用 0 来填充这个空位。但在线性反馈移位寄存器中，我们使用 F(s)来决定这个位该填 1 还是填 0。在 F(s)中，s 是先前寄存器中的值，而 F 是一个映射到 1bit 的线性函数。

一般的做法就是用多个异或门构成组合逻辑电路将 s 的每位作为输入进行处理，最后仅输出一个 1bit 的值，然后将这个输出作为结果填充到移位时产生的空位，由此来实现函数 F。

赋予给寄存器的初始值叫做“种子”，显然这个种子确定了接下来 LFSR 会生成的伪随机数。 

### 7.6.3.1 非线性反馈移位寄存器(NLFSR，Non-linear Feedback Shift Register)

顾名思义，NLFSR 就是将线性反馈移位寄存器中的线性函数 F 改为非线性函数 G。对于 NLFSR，一般的做法是采用多个与门和异或门构成组合逻辑电路来实现函数 G。

除生成伪随机数外，LFSR 和 NLFSR 还在加密、纠错等方面有用。关于它们就不做更多介绍了，如果你要用到它们，可以自行了解。
