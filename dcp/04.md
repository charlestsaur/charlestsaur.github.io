

### 4.3 数制(NUMBER SYSTEM)、数码(DIGIT)、基数(RADIX)、位权(WEIGHT)

现在我们知道 k 进制每位有 k 种符号了。通过之前的表格我们已经对进制的规律管窥一斑，但应该如何准确描述这些东西呢?这就是接下来要学习的东西。为了准确描述“k 进制”的基本特征，我们需要用到以下术语:

| 术语      | 解释                                                                                                      |
|---------  |---------------------------------------------------------------------------------------------------------  |
|   数制    |   各种进制的总称，如二进制、十进制等等，它们的总称就叫数制。                                             |
|   数码    |   别名数字，表示数的符号。比如十进制有 10 个数码，分别是 0、1、2、3、4、5、6、7、8、9。                  |
|   基数    |   数制拥有的数码的数量，比如十进制有 10 个数码，那它的基数为 10。同理 16 进制的基数为 16。               |
|   位权    |   第 n 位的权重，比如十进制第 2 位的位权是 10，第 3 位的位权是 100。以此类推。 其实就是第 n 位的大小。    |


数制、数码、基数与位权的解释

上表解释了这四个术语的含义。接下来重点关注一下位权，这里用一张表展示不同进制第 n 位的位权:

不同进制的第 n 位的位权 (k 进制的第 n 位的位权为k(n−1)，表中数据均为十进制数)

|         | 第 1 位   |  第 2 位    |  第 3 位    |  第 4 位    |  第 5 位    |  第 6 位    |  第 7 位    |  第 8 位    |   第 n 位   |
|:------: |:--------: |:---------:  |:---------:  |:---------:  |:---------:  |:---------:  |:---------:  |:---------:  |:----------: |
| 10进制  |     1     |     10      |    100      |    1000     |   10000     |   100000    |  1000000    |  10000000   | $10^{n-1}$  |
|  2进制  |     1     |     2       |     4       |     8       |     16      |     32      |     64      |    128      |  $2^{n-1}$  |
|  8进制  |     1     |     8       |     64      |    512      |    4096     |   32768     |   262144    |  2097152    |  $8^{n-1}$  |
| 16进制  |     1     |     16      |    256      |    4096     |   65536     |  1048576    |  16777216   | 268435456   | $16^{n-1}$  |

表中贴心地直接告诉了你 k 进制第 n 位位权的计算公式是k$^{n-1}$，也就是说现在你可以用这个公式计算出 k 进制第 n 位代表的大小(即位权)是多少了。位权是沟通不同进制的一栋桥梁，利用位权可以转换进制。

### 4.3.1 位权与进制转换(Radix Transfer)

已知这里有一个二进制数 $1001_2$，如何才能求出它对应的十进制数呢?根据位权公式我们知道，二进制数前四位的位权分别是 1$_10$、2$_10$ 、4$_10$ 、8$_10$。于是我们让二进制的每位乘上所对应的位权，得到:

$1_{10} \times 8_{10} + 0_{10} \times 4_{10} + 0_{10} ×2_{10}  + 1_{10} \times 1_{10} = 9_{10}$

这样就知道了 10012 对应的十进制数是 910。 再举个例子，现在求出 2510 所对应的二进制数:

$2_{10} ×10_{10} +5_{10} ×1_{10} = 10_{2} ×1010_{2} +101_{2} ×1_{2} = 11001_{2}$

因为要求得的是二进制数，所以还得先把十进制数转换成二进制数，然后在二进制下进行计算求出结果。虽然暂时还没学二进制的 运算，但这不是现在的重点。

在这个计算步骤中可以注意到，我们只需要列出 0、1、2、3、4、5、6、7、8、9 和 10、100、1000、10000...这些十进制数对应的 二进制数就可以把左边的十进制数式转换成右边的二进制数式，因为式中就只出现了这些数。

0、1、2、3、4、5、6、7、8、9 这些数对应的二进制数可以直接事先算出来然后存在一张表里，计算时如果需要直接查表即可，这 种思想叫做查表法。查表法事先将计算结果存在表中，而在计算时直接查表得到结果，从而避免了繁琐的计算过程。

在计算结果较小的情况下，对于 10、100、1000、10000...也可以采用查表法。但即使不用查表法也可以专门推理出这些数与二进制 的对应规律关系。显然这比直接找出所有十进制数与二进制数的对应规律关系要简单得多。

进制转换的算法非常多，但都是基于位权原理的，在后文讨论进制转换器时会介绍更多进制转换算法。

#### 4.3.2 k 进制的正式定义

k 进制:基数为 k，第 n 位位权为 k(n-1)的数制。


5.4 二进制数(BINARY)的运算 现在我们就来学习如何计算二进制数。其实不同进制的运算方法都是一样的，还记得你小时候用的加减乘除竖式吗?二进制也可以用竖式来解决加减除，如:

$
\begin{array}{ccc}
&1&1\\
+&1&0\\
\hline
1&0&1
\end{array}
$

$
\begin{array}{ccc}
&1&1\\
-&1&0\\
\hline
&0&1
\end{array}
$

$
\begin{array}{ccc}
&1&1\\
\times&1&0\\
\hline
1&1&0
\end{array}
$

除法竖式也一样，我就不列了。类似地，其它进制也可以这样列竖式来计算加减乘除。

关于进位，在十进制中有 $9+1=10$，这叫逢 10 进 1。而在二进制中有 $1+1=10$，这叫逢 2 进 1。以此类推，在 k 进制中就有逢 k 进 1。这就是 k 进制的进位规律。

至于加减乘除以外的算法，也可以类似地从十进制算法推广得到。或者你也可以先将其它进制数转换为十进制数，然后用我们熟悉的十进制算法计算出结果，最后再将结果转回原进制表示。(用抽象代数的话说，不同数制是同构的。)

数字电路中几乎所有的运算器都是在二进制下进行运行的，这是因为用二进制的运算器更容易实现(其实不止运算器，其它电路模 块也是)。所以我们主要关注的也是二进制运算器的算法。

### 4.5 二进制小数

不同进制的第 n 位小数的位权 (k 进制的第 n 位小数的位权为𝑘−𝑛，表中数据均为十进制数)

|     <br>      |   <br>第 1 位小数     |   <br>第 2 位小数     |   <br>第 3 位小数     |    <br>第 4 位小数    |    <br>第 5 位小数    |    <br>第 6 位小数    |    <br>第 7 位小数      |    <br>第 8 位小数      |  <br>第 n 位小数    |
|:------------: |:-------------------:  |:-------------------:  |:-------------------:  |:--------------------: |:--------------------: |:--------------------: |:---------------------:  |:---------------------:  |:-----------------:  |
|  <br>10进制   |       <br>0.1         |       <br>0.01        |      <br>0.001        |      <br>0.0001       |      <br>0.00001      |     <br>0.000001      |     <br>0.00000001      |    <br>0.000000001      |   <br>$10^{-n}$     |
|   <br>2进制   |  <br>$\frac{1}{2}$    |  <br>$\frac{1}{4}$    |  <br>$\frac{1}{8}$    |  <br>$\frac{1}{16}$   |  <br>$\frac{1}{32}$   |  <br>$\frac{1}{64}$   |  <br>$\frac{1}{128}$    |  <br>$\frac{1}{256}$    |    <br>$2^{-n}$     |

上表给出了 k 进制第 n 位小数位权的公式𝑘−𝑛，它的形式跟 k 进制第 n 位数位权公式𝑘(𝑛−1)很像。实际上，如果把第 1 位小数改名叫 第 0 位数，第 n 位小数叫第 1-n 位数的话，带入𝑘(𝑛−1)也可以算出小数的位权。这样来看小数和整数的位权公式其实是统一的。

不同进制的小数的计算也可以通过列竖式来完成，就跟十进制小数的竖式一样。小数的进制转换思路跟整数的进制思路一样，都是 每位乘与对应位权然后求和。

### 4.6 有限位数(FINITE NUMBER SYSTEM)与比特(BIT)

所谓的有限位数就是位数有限的数。比特是一个单位，符号为 bit 或者简写为 b，复数形式为 bits。比特可以用于描述一个有限位二进制数有多少位，比如我们可以用 8bits 来形容一个 8 位的有限位二进制数。此外还有一些其它单位，它们与 bit 之间的关系是:

* 1byte = 8bits

* 1KiB = 1024bytes

* 1MiB = 1024KiB

* 1GiB = 1024MiB

* 1TiB = 1024GiB

是不是很熟悉?它们就是你的电脑硬盘的存储大小单位。但是你的电脑上显示的是 MB 而不是 MiB，是 GB 而不是 GiB，这是为什么 呢?除了可能只是有的地方单纯习惯省略中间的 i 外，也有可能是因为它们采用了这套标准(SI 标准):

* 1KB = 1000Bytes

* 1MB = 1000KB

* 1GB = 1000MB

* 1TB = 1000GB

某些骗子会混淆这两种标准来忽悠外行人。此外，它们其实还有更大的单位比如 PB，感兴趣可以自己去了解。

回到正题，有限位数只能在它的位数范围内表示数，如果计算超出了它的表示范围，那么超出表示范围的数值就会被抛弃。

比如一个 8bits 的有限位数算式是 $1111 1111 +1=0000 0000$，式中结果的表示范围只有 8bits，于是正确结果 $1 0000 0000$ 中的第九位被丢失了。

有限位数因为表示范围有限而丢失数值或导致计算结果出错的情况叫做溢出。

除了刚才这种情况，小数精度不足也同样可以导致溢出。例如让一个精确到第二位小数的有限位数表示 $\frac{1}{99999}$ 的话，它只能四舍五入到零，因为它本身最多只能精确表示到第二位小数。

另外，减法也可以导致溢出，比如一个有限位数的表示范围在 $+127$ 到 $-127$ 之间 的话，那么它肯定不能表示小于 $-127$ 的数，因此在计算时产生小于 $-127$ 的结果时就会导致结果出错，也就是溢出。

### 4.7 位运算(BITOPERATION)

|     名称      |      符号       |  解释                                                               |
|:------------: |:--------------: |-------------------------------------------------------------------- |
|      与        |   A $\And$ B    | A 和 B 的每位分别进行与逻辑运算。如 $1101 \And 0100 = 0100$。       |
|      或        |   A $\mid$ B    | A 和 B 的每位分别进行或逻辑运算。如 $1000 \mid 0001 = 1001$。       |
|      非        |   $\bar{A}$     | A 的每位分别取反。如 $\overline{0100}$ = 1011。                     |
|     异或      |  A $\oplus$ B   | A 和 B 的每位分别进行异或逻辑运算。如 1001 $\oplus$ 1011 = 0010。    |
|     同或      |   A $\odot$ B   | A 和 B 的每位分别进行同或逻辑运算。如 1001 $\odot$ 1011 = 1101。     |
|  (逻辑)左移   |    A $\ll$ B    | 让A左移s位，移出的空位用0补充。如 $00001101 \ll 410 =11010000$。    |
|  (逻辑)右移   |    A $\gg$ B    | 让A右移s位，移出的空位用0补充。如 $10100000 \gg 410 =00001010$。    |

8bits 有符号数的结构。其中 A 和 B 均为 n bit(s)的有限位二进制数，s 必须大等于 0。除了逻辑移位还有算数移位，但这里暂不讨论算数移位。

上表总结了各种位运算的定义，你会发现它们其实就是以前学的逻辑运算的拓展，就连符号都一样。逻辑运算只负责处理 1bit 的运 算，而位运算能处理 n bit(s)的运算。左移和右移是新的东西，它们叫移位运算，用于移动二进制位。有时如果移太多位会导致溢出，如 0001<<510=0000，数值被移到了表示范围外所以溢出了。为方便有时会规定在溢出时自动拓展位数，如 01<<210=100，以避免溢出。

(逻辑)左移和(逻辑)右移还有两个有用的性质，在不溢出或者自动拓展位数的情况下有:

$A \ll S= A \times 2^S$

$A \gg S= \frac{A}{2^S}$

在运算器中这两条性质常被用于代替一些特殊的乘法和除法，因为移位运算电路很简单。想一想，这两条性质是如何成立的呢?

### 4.8 有符号数(SIGNEDNUMBER)

在计算机中可以用有符号数表示有符号的数值。相对地，无符号数用于表示没有符号的数。有符号数是一个 n bit(s)的有限位数，通常用它的最高位(第 n 位)用来表示符号，一般规定最高位为 0 时为正，为 1 时为负。以一个 8bits 的有符号数为例:

<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
    overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
    font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top}
</style>
<table class="tg">
<thead>
    <tr>
        <td class="tg-c3ow">第 8 位(符号位) </td>
        <td class="tg-c3ow"> 第 7 位 </td>
        <td class="tg-c3ow"> 第 6 位 </td>
        <td class="tg-c3ow"> 第 5 位 </td>
        <td class="tg-c3ow"> 第 4 位 </td>
        <td class="tg-c3ow"> 第 3 位 </td>
        <td class="tg-c3ow"> 第 2 位 </td>
        <td class="tg-c3ow"> 第 1 位 </td>
    </tr>
</thead>
</table>

一个 8bits 有符号数的结构

它的最高位变成了符号位，所以它只有 7 个位来表示实际的数值。一个无符号 8bits 数的表示范围是 255 到 0，而 8bits 的有符号数的表示范围是+127 到-127。而且，有符号数有+0 和-0 之分。以 8bits 的有符号数为例，0000 0000 表示+0，1000 0000 表示-0。

有符号数的符号位不应该接受或产生进位，否则可能出错。以 8bits 有符号数的一个加法算式为例，如果符号位接受进位，那么会有:0100 0000+0100 0010=1000 0010，转换成十进制表示就是 64+66=-2，显然是错的。

有符号数还有个问题，那就是它不能直接计算 A+(-B)。以两个 8bits 有符号数的加法 0011 0011+1011 0000 为例，正确的结果应该是0000 0011，但是如果直接用加法竖式去算 0011 0011+1011 0000 的话显然得不到这个正确结果。

有符号数如果要计算 A+(-B)，只能先把它变成 A-B 再计算出结果。还是以 0011 0011+1011 0000 为例，正确的计算过程应该是:

0011 0011 + 1011 0000 = 0011 0011 − 0011 0000 = 0000 0011

那么有没有一种表示方法，能够直接计算 A+(-B)呢?答案是有的，它就是接下来要介绍的补码。

### 4.9 原码(SIGN MAGNITUDE)、反码(1‘s COMPLEMENT)、补码(2‘s COMPLEMENT)

|  名称  	|    符号    	| 求法                                                                                                                                                                                                                                             	|
|:------:	|:----------:	|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	|
|  原码  	|  $[N]_原$  	| 原码就是有符号数。                                                                                                                                                                                                                               	|
|  反码  	|  $[N]_反$  	| $[N]_原>0 或[N]_原=+0$ 时:$[N]_反=[N]_原$。<br>$[N]_原<0 或[N]_原=-0$ 时:将 $[N]_原$ 符号位以外的其它位取反就能得到 $[N]_反$。                                                                                                          	|
|  补码  	|  $[N]_补$  	| $[N]_原>0 或[N]_原=+0$ 时:$[N]_补=[N]_原$。<br>$[N]_原<0$ 时:$[N]_补=[N]_反+1$。(对于小数，请将+1 改为加上最低位的位权，如 0.111+0.001,就是给小数的最低位加个 1。) <br>$[N]_原=-0$ 时:将 $[N]_原$ 的符号位设置为 0 就能得到 $[N]_补$。 	|

原码、反码与补码的求法。后文我们会系统地介绍各种不同的数表示系统，届时我们会发现，上表中的反码和补码只是广义的补码表示系统的特例

| 十进制数 	|  +7  	|   +6 	|  +5  	|  +4  	|  +3  	|  +2  	|  +1  	|  +0  	|  -0  	|  -1  	|  -2  	|  -3  	|  -4  	|  -5  	|  -6  	|  -7  	|  -8  	|
|:--------:	|:----:	|:----:	|:----:	|:----:	|:----:	|:----:	|:----:	|:----:	|:----:	|:----:	|:----:	|:----:	|:----:	|:----:	|:----:	|:----:	|:----:	|
|   原码   	| 0111 	| 0110 	| 0101 	| 0100 	| 0011 	| 0010 	| 0001 	| 0000 	| 1000 	| 1001 	| 1010 	| 1011 	| 1100 	| 1101 	| 1110 	| 1111 	|  无  	|
|   反码   	| 0111 	| 0110 	| 0101 	| 0100 	| 0011 	| 0010 	| 0001 	| 0000 	| 1111 	| 1110 	| 1101 	| 1100 	| 1011 	| 1010 	| 1001 	| 1000 	|  无  	|
|   补码   	| 0111 	| 0110 	| 0101 	| 0100 	| 0011 	| 0010 	| 0001 	| 0000 	|  无  	| 1111 	| 1110 	| 1101 	| 1100 	| 1011 	| 1010 	| 1001 	| 1000 	|

一些十进制数(+7 到-8)所对应的原码、反码、补码(原码、反码、补码都被限定为了 4bits 的有限位数)

上面给出了原码、反码、补码的符号和求法。(严格来说这里讨论的补码叫 2 的补码，此外还有模 M 补码等，反码也叫 1 的补码)

与不同数制一样，这些不同码制也很容易被混淆，比如上表中的 1111 既可以是补码中的 1111 也可以是原码或反码中的 1111。和区分进制的做法类似，我们用方括号将数值圈起来，并且在右下角标注这个数的码字以区分码制。例如 $[0101]_补$，看到这个数的右下角我们就知道它是补码，而不是反码或者原码。

你可能会被第一张表中的 $[N]_原、[N]_反、[N]_补$ 绕晕。如果会的话，请记住 N 是抽象的，N 本身不涉及具体的表示。$[N]_原、[N]_反、[N]_补$ 的意思分别是 N 这个数的原、反、补码表示。原、反、补码本质上只是有符号数的不同表示方式，就跟不同数制一样。

运算时，原码和反码的符号位都不会接受进位。但补码的符号位会接受进位。也就是说补码符号位会接受上一位的进位，且一般会忽略补码产生的溢出。这些规定很自然，例如按规定(忽略溢出)有:$[1111]_补+[0001]_补=[0000]_补$，用十进制表示就是 $-1+1=0$，完全正确。

如果你想问不同码制间的运算是什么情况(如 $[N]_原+[N]_反$)，那我会告诉你这是未定义的。运算的前提就是参与运算的数的码制相同，就好比二进制不能跟十进制直接相加(如 $101_{(2)}+12_{(10)}$)，必须先把数制统一再来计算。虽然它们可以相互转换，但也需要先统一后计算。

如果这里有两个 n bit(s)的原码 $[A]_原$ 和 $[B]_原$，那么根据定义可以知道它们分别对应的补码具有以下性质(读者可尝试自行推导):

$[A]_补 + [B]_补 = [A + B]_补$

$[A]_补 −[B]_补 = [A]_补 +[−A]_补 = [A−B]_补$

第二条公式说明补码可以直接计算 A+(-B)。利用这点，可以先取 -B 的值，然后用加法替代减法(A+(-B)代替 A-B)。在设计运算器时如果利用这条性质，可以让单独一个加法器完成加法和减法两种运算。

补码没有+0 和-0 之分，因此它的表示范围比原码和反码要稍微大那么一点(如上面的表)。以 8bits 的原码、反码、补码为例，原码和反码的表示范围是+127 到-127，而补码的表示范围则是+127 到-128。n bit(s)的情况以此类推。

正是补码具有如此多的良好性质，在计算机中一般都会统一用补码来表示带正负的数，而不是直接用有符号数。

可以把补码理解成一个时钟。假如现在它的时间在 13:00，要把时间调到 11:00 该怎么做?有两个办法，第一种方法就是让时针 逆时针拨动 2 小时，第二种方法是将时针往前顺时针拨动 22 小时。补码计算 A+(-B)的办法本质上跟第二种方法一样，以增代减。

有限位数跟时钟一样，都是循环的，以 4bits 无符号数为例，因为溢出，1111+0001=0000。就像 24:00 的下一点是 1:00 一样，从终点又回到了起点。如果不停给这个无符号数+1，那它会在这 4bits 里像时钟一样不停循环。(数学中类似的概念叫商群)